/*
 * generated by Xtext 2.20.0
 */
package kcl.ac.uk.jian.building.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import kcl.ac.uk.jian.building.building.BuildingProgram
import kcl.ac.uk.jian.building.building.AddFloorProcess
import kcl.ac.uk.jian.building.building.IntLiteral
import kcl.ac.uk.jian.building.building.RealLiteral
import kcl.ac.uk.jian.building.building.Expression
import kcl.ac.uk.jian.building.building.PaintProcess
import kcl.ac.uk.jian.building.building.AddWindowProcess

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BuildingGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as BuildingProgram
		val className = resource.deriveClassNameFor
		fsa.generateFile(className + '.java', model.doGenerateClass(className))
	}
	
	def deriveClassNameFor(Resource resource) {
		val origName = resource.URI.lastSegment
		origName.substring(0, origName.indexOf('.')).toFirstUpper + 'Building'
	}
	
	def String doGenerateClass(BuildingProgram program, String className)'''
		import java.awt.Color;
		import java.awt.Graphics;
		import java.awt.Polygon;
		import java.util.Map;
		import java.util.HashMap;
		
		import javax.swing.JComponent;
		import javax.swing.JFrame;
		
		public class «className» {
			public static void main(String[] args) {
				JFrame window = new JFrame();
				window.setSize(1000, 1000);
				window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				Picture pic = new Picture();
				window.add(pic);
				window.setVisible(true);
			}
		}
		class Picture extends JComponent{
			protected void paintComponent(Graphics g) {
				g.setColor(Color.green);
				Polygon p = new Polygon();
				int height = 50, width = 250;
				int x = 380, y = 450;
				int offset = 30;
				p.addPoint(x, y);
				p.addPoint(x - offset, y + height);
				p.addPoint(x + width - offset, y + height);
				p.addPoint(x + width, y);
				g.fillPolygon(p);
				structure s = new structure();
				g.setColor(Color.black);
				g.fillRect(460, 470, 60, 30);
				g.setColor(Color.gray);
				g.drawLine(460, 500, 520, 500);
				«program.processes.map[generateJavaStatement(new Environment)].join('\n')»
				g.setColor(Color.cyan);
				g.fillRect(490, 480, 10, 20);
				g.setColor(Color.yellow);
				g.fillRect(470, 480, 10, 10);
				for(int i = 0; i <= s.getAbove(); i++){
					g.setColor(Color.yellow);
					g.fillRect(470, 480 - 30 * i, 10, 10);
					g.setColor(Color.gray);
					g.drawLine(460, 500 - 30 * i, 520, 500 - 30 * i);
				}
				for(int i = 0; i <= s.getUnder(); i++){
					g.setColor(Color.yellow);
					g.fillRect(470, 480 + 30 * i, 10, 10);
					g.setColor(Color.gray);
					g.drawLine(460, 500 + 30 * i, 520, 500 + 30 * i);
				}
				Map extraWindow = s.getExtraWindow();
				for(int i = -s.getUnder(); i <= s.getAbove(); i++) {
					if(extraWindow.containsKey(i)) {
						int windows = Integer.parseInt(extraWindow.get(i).toString());
						g.setColor(Color.yellow);
						for(int j = 1; j <= windows; j++){
							g.fillRect(470 + 20 * j, 480 - 30 * i, 10, 10);
						}
					}
				}
			}
		}
		class structure{
			int above;
			int under;
			Map extraWindow = new HashMap();
			
			void setAbove(int above) {
				this.above = above;
			}
			
			int getAbove() {
				return this.above;
			}
			
			void setUnder(int under) {
				this.under = under;
			}
			
			int getUnder() {
				return this.under;
			}
			
			void addExtraWindow(int floor, int extra) {
				this.extraWindow.put(floor, extra);
			}
			
			Map getExtraWindow() {
				return this.extraWindow;
			}
		}
	'''
	
	private static class Environment {
		var int counter = 0

		def getFreshVarName() '''i«counter++»'''

		def exit() { counter-- }
	}
	
	dispatch def String generateJavaStatement(Process proce, Environment env)''''''
	
	dispatch def String generateJavaStatement(AddFloorProcess proce, Environment env)'''
		g.setColor(Color.black);
		if("«proce.structure.getName.toLowerCase»".equals("aboveground")){
			s.setAbove(«proce.levels.generateJavaExpression»);
			g.fillRect(460, 470 - 30 * «proce.levels.generateJavaExpression», 60, 30 * «proce.levels.generateJavaExpression»);
		}
		else if("«proce.structure.getName.toLowerCase»".equals("underground")){
			s.setUnder(«proce.levels.generateJavaExpression»);
			g.fillRect(460, 470 + 30, 60, 30 * «proce.levels.generateJavaExpression»);
		}
	'''
	
	dispatch def String generateJavaStatement(PaintProcess proce, Environment env)'''
		g.setColor(Color.«proce.color.toLowerCase»);
		g.fillRect(460, 470 - 30 * «proce.levels.generateJavaExpression», 60, 30);
	'''
	
	dispatch def String generateJavaStatement(AddWindowProcess proce, Environment env)'''
		s.addExtraWindow(«proce.levels.generateJavaExpression»,«proce.num.generateJavaExpression»);
	'''
	
	dispatch def String generateJavaExpression(Expression exp) {}

	dispatch def String generateJavaExpression(IntLiteral exp) '''«exp.^val»'''

	dispatch def String generateJavaExpression(RealLiteral exp) '''«exp.^val»f'''
}
